function result = ortho2005(args,varargin)
% function result = ortho2005(args,varargin)
%
% (c) 2005 Luis Hernandez-Garcia
% University of Michigan
% report bugs to:  hernan@umich.edu
%
% last edits: Oct 18,2005
%
% This is a program to visualize overlays of FMRI data, extract time
% series and do some quick analyses on those time series like FFT, gaussian
% filters, event averaging, detrending.
% Images should be in Analyze (AVW) format
%
%
%         USAGE:
%
% This program will do as much as it can with the information provided.
% ie - If you give onset times, it will assume you want event averages,
% You can run this program in a couple of ways:
% The arguments to this function can go in either as a structure like this:
% (fell free to copy and paste the following in order to run the program.  it's what I do)
%
%     args.ROIsize = 0;
%     args.ROItype = 'cube';
%     args.threshold = 0.0001;
%     args.threshold2 = 0.0001;
%     args.onsets = [];
%     args.window = 10;
%     args.spm_file = [];
%     args.spm_file2 = [];
%     args.anat_file = [];
%     args.tseries_path = [];
%     args.tseries_file = [];
%     args.tseries_file2 = [];
%     args.doDetrend = 0;
%     args.doGfilter = 0;
%     args.doFFT = 0;
%     args.ignore_origin = 0;
%     args.wscale = [];
%     args.interact = 1;
%     args.xyz=[];
%     args.mask_file = [];
%     args.output_name = 'Ortho';
%     args.voxFile = [];
%     args.doMovie = 0;
%     args.causalMap = 0;
%
% then you call
%
%   ortho2005(args)
%
% OR as variable arguments when you just want to change a couple of the
% defaults. The general syntax is
%
%   ortho2005([],'argument1', value1, 'argument2', value2, ....)
%
% for example:
%
%    ortho2005( [], 'anat_file', '/usr/data/vol_0001.img', 'ROIsize', 1);
%
%
%
%       INPUTS (arguments).
%       (their default values are in the above struct)
%
% ROIsize : this is the 'radius' of the ROI if it's a sphere
%       or the number of neighbors to consider if it's a cubw.
%       it's in mm for the sphere case, and voxels for the cube case
%
% ROItype :  what type of ROI you'll useyou can choose
%       'cube' : average the neighbors in each direction
%       'voxFile': average the values in the voxels specified in an ASCII file
%       'sphere':  average the voxels in a sphere, but only those whose
%              statistics are above threshold
%       'maskFile'  : average the voxels that are non-zero in a mask img file
%
% threshold : statistic theshold for display of the overlay and for ROI
%       averaging.
%
% threshold2 : statistic theshold for display of the overlay and for ROI
%       averaging of the second stats map.
%
% voxFile : an ASCI file containing three columns specifying which voxels
%       to extract time series from.  Note- uses scan units and ignores the
%       origin by default.
%
% mask_file = binary mask image to use if you want to choose your ROIs that
%       way
%
% onsets : a vector of onset times, specified in scan units for window averaging;
%
% window : The window of time to average after ach onset (peristimulus interval)
%       also in units of scans;
%
% spm_file : The statistical map to overlay on the orthogonal views;
%
% anat_file : The anatomical image file to overlay;
%
% tseries_path :  this doesn't do aquat right now
%
% tseries_file : one of the files in the time series.
%       If the data are 4D, ortho2005 should recognize it and read it in= [];
%
% tseries_file2 :  this doesn't do squat yet, either = [];
%
% doMovie : show a movie loop of the time series. only the time series
%       image is required
%
% doDetrend :  Detrend the data by fitting and removing a 4th order polynomial.
%       usually works like a charm!;
%
% doGfilter:  Filter the data with a simple Gaussian filter in time.
%       kernel width (SD) is hard wired to 4 scans ;
%
% doFFT :  show the FFT magnitude and phase of the time series in a separate window;
%
% ignore_origin :  ignore the origin information from SPM.  This can be tricky;
%
% wscale :  window level scaling for display of the anatomical images
%       if you want to do it manually;
%
% interact : allow the user to interactively pick points from the image, or just
%       do one set of coordinates and exit the program.  When interactive,
%       you exit the program by clicking to the left of the images, or by
%       hitting the Z key.
%
% xyz : voxel coordinates to analyse when not running interactively.
%
% output_name : a prefix to put on all the files generated by the program ('Ortho');
%
% causalMap : this will launch a set of programs that takes the time course from
%       the chosen ROI as an examplar and computes maps (img files)
%       of the following measures of relationship between the ROI and other voxels:
%          -Ganger causality : F, Fa->b , Fb->b, pvalue(F)
%          -Mutual Information:
%          -correlation coefficient (rho)
%          -DOminance
%          -Asymmetry of the joint histogram
%
%       Outputs from ortho2005
%
%  you get some very nice displays of whatever you chose.  if you click the
%  right mouse button instead of the left one, you get these ASCII files:
%
%       *voxels.dat : the voxels that data was extracted from
%       *data.dat: the raw time series data from theose voxels
%       *avg.dat : the means and standard deviation of the events
%
%

global args
if ~exist('args')
    args = [];
end

if isempty(args)
    args.ROIsize = 0;
    args.ROItype = 'cube';
    args.threshold = 0.0001;
    args.threshold2 = 0.0001;
    args.onsets = [];
    args.window = 20;
    args.spm_file = [];
    args.spm_file2 = [];
    args.anat_file = [];
    args.tseries_path = [];
    args.tseries_file = [];
    args.tseries_file2 = [];
    args.doDetrend = 0;
    args.doGfilter = 0;
    args.doFFT = 0;
    args.ignore_origin = 1;
    args.wscale = [];
    args.interact = 1;
    args.xyz=[];
    args.mask_file = [];
    args.output_name = 'Ortho';
    args.voxFile = [];
    args.doMovie = 0;
    args.causalMap = 0;
end

if nargin==0
    result=args;
    return
end

% Parse the arguments from the command line to override defaults
for a=1:2:length(varargin)

    argtype = lower( cell2mat(varargin(a) ));

    if  strcmp(argtype, 'roisize');
        args.ROIsize = cell2mat(varargin(a+1));

    elseif  strcmp(argtype, 'roitype');
        args.ROItype = cell2mat(varargin(a+1));

    elseif  strcmp(argtype, 'threshold');
        args.threshold = cell2mat(varargin(a+1));

    elseif  strcmp(argtype, 'onsets')
        args.onsets = cell2mat(varargin(a+1));

    elseif  strcmp(argtype, 'window')
        args.window = cell2mat(varargin(a+1));

    elseif  strcmp(argtype, 'spm_file');
        args.spm_file = cell2mat(varargin(a+1));

    elseif  strcmp(argtype, 'spm_file2');
        args.spm_file2 = cell2mat(varargin(a+1));

    elseif  strcmp(argtype, 'anat_file')
        args.anat_file = cell2mat(varargin(a+1));

    elseif  strcmp(argtype, 'tseries_path')
        args.tseries_path = cell2mat(varargin(a+1));

    elseif  strcmp(argtype, 'tseries_file')
        args.tseries_file = cell2mat(varargin(a+1));

    elseif  strcmp(argtype, 'tseries_file2')
        args.tseries_file2 = cell2mat(varargin(a+1));

    elseif  strcmp(argtype, 'dodetrend')
        args.doDetrend = cell2mat(varargin(a+1));

    elseif  strcmp(argtype, 'dotsmooth')
        args.doTsmooth = cell2mat(varargin(a+1));

    elseif  strcmp(argtype, 'dofft')
        args.doFFT = cell2mat(varargin(a+1));

    elseif  strcmp(argtype, 'domovie')
        args.doMovie = cell2mat(varargin(a+1));

    elseif  strcmp(argtype, 'ignore_origin')
        args.ignore_origin = cell2mat(varargin(a+1));

    elseif  strcmp(argtype, 'wscale')
        args.wscale = cell2mat(varargin(a+1));

    elseif  strcmp(argtype, 'interact')
        args.interact = cell2mat(varargin(a+1));

    elseif  strcmp(argtype, 'xyz')
        args.xyz = cell2mat(varargin(a+1));

    elseif  strcmp(argtype, 'mask_file')
        args.mask_file = cell2mat(varargin(a+1));

    elseif  strcmp(argtype, 'output_name')
        args.output_name = cell2mat(varargin(a+1));

    elseif  strcmp(argtype, 'voxfile')
        args.voxFile = cell2mat(varargin(a+1));

    elseif  strcmp(argtype, 'causalmap')
        args.causalMap = cell2mat(varargin(a+1));

    else
        fprintf('\n\n  UNKNOWN OPTION: %s ', argtype);
        fprintf('\n  Get your act together \n\n');
    end

end

if isempty(args.anat_file)
    args.anat_file=args.tseries_file;
end

args

global SPM_scale_factor
global myfig ACTIVE EvFig FFTfig histFig
ACTIVE = 1;
% define some buttons for interactively adjusting the ROIsize and threshold
% the default will be for a WINPC, although I never use one....
UPKEY = 30;
DNKEY = 31;
RTKEY = 29;
LTKEY = 28;
i=1;
j=1;
if strcmp(computer,'GLNX86') || ...
        strcmp(computer,'SOL2')|| ...
        strcmp(computer,'MACI')
    UPKEY = 30;
    DNKEY = 31;
    RTKEY = 29;
    LTKEY = 28;
end
if strcmp(computer,'MAC')
    UPKEY = 56;
    DNKEY = 50;
    RTKEY = 54;
    LTKEY = 52;
end

isNIFTI=0;

if ~isempty(args.onsets)
    % open a window for displaying the time courses
    EvFig = figure;
    set(gcf,'Position',[1 1 400 300]);
    set(gcf, 'Name', 'Events image')
end

if args.doFFT
    % open a window for displaying the frequency content of the time courses
    FFTfig = figure;
    set(gcf,'Position',[400 1 400 300]);
    set(gcf, 'Name', 'Frequency Spectrum')
end

histFig = figure;
set(gcf,'Position',[400 400 400 380]);
set(gcf, 'Name', 'Histograms')

myfig = figure;
set(gcf, 'Name', 'Orthogonal Views')
set(gcf,'Position',[1 400 400 380]);

if ~isempty(args.anat_file)
    % Load the anatomical image into memory:
    anat_file = args.anat_file;
    hdr = read_hdr(anat_file);

    if hdr.xsize < 0;
        fprintf('\nWARNING: found neg. xsize in Anatomical header. Ignoring the sign.');
        fprintf('\nIs this right? Look for THIS in the code and change if you dont like it');
        hdr.xsize = abs(hdr.xsize);
    end

    fprintf('\nLoading ... %s', anat_file);
    anat_data = read_img(hdr,anat_file);
    % identify whether this is already a 3D matrix. If not, make it a 3D matrix
    if (size(size(anat_data),2) < 3)
        anat_data = reshape(anat_data(1,:), hdr.xdim, hdr.ydim, hdr.zdim);
    end
    anat_scale =  SPM_scale_factor;

    %anat_data = anat_data*anat_scale;

    fprintf('\nheader info: %d x %d x %d', hdr.xdim, hdr.ydim, hdr.zdim);
    fprintf('\nvox size: %d x %d x %d', hdr.xsize, hdr.ysize, hdr.zsize);

    D = anat_data;

    if isempty(args.spm_file)
        % configure colormap
        my_map=(0:255)';
        my_map=[my_map my_map my_map]/256;
        colormap(my_map);
    end
    % scale image to fit colormap
    
    if ~isempty(args.wscale)
        wscale = args.wscale
        D = (D - wscale(1))*256 / (wscale(2)-wscale(1));
		D(find(D>256)) = 256;
		D(find(D<1)) = 1;
	else

		range= max(D(:)) - min(D(:));
		%range = 2*std(D(:))
		%D = (D - median(D(:))- range/2 )*256 / range;
        D = (D - min(D(:)))*256 / range;
		%D = (D - median(D(:))- range/2 )*256 / range;
        
    end
    Dscaled = D;
end
figure(histFig), subplot(3,1,1),hist(double(anat_data(anat_data~=0)),100), title('Anatomical')
figure(myfig)


if ~isempty(args.spm_file)
    % load SPM into memory and create the overlay
    spm_file = args.spm_file;
    fprintf('\nLoading ... %s', spm_file);
    spm_hdr = read_hdr(spm_file);
    spm_data = read_img(spm_hdr,spm_file);
    spm_data = double(spm_data);
    % get rid of the NaNs
    spm_data(find(spm_data==NaN))=0;
    spm_data = reshape(spm_data, spm_hdr.xdim, spm_hdr.ydim, spm_hdr.zdim);
    spm_scale =  SPM_scale_factor;

    %spm_data = spm_data*spm_scale;
    figure(histFig), subplot(3,1,2),hist(spm_data(spm_data~=0),100), title('Stats Map (Red)')
    figure(myfig)
	subplot(2,2,4), hist(spm_data(spm_data~=0),100), axis on, title('Stats Map'), 

    % resample the paramter map to fit the anatomical one
    [x,y,z] = meshgrid(1:spm_hdr.ydim , 1:spm_hdr.xdim, 1:spm_hdr.zdim);
    [xi,yi, zi] = meshgrid(1:hdr.ydim , 1:hdr.xdim, 1:hdr.zdim);

    % optional in case the origin is not set in the image headers...
    if args.ignore_origin==1
        spm_hdr.origin = [0 0 0];
        hdr.origin = [0 0 0];
    end

    if spm_hdr.xsize < 0;
        fprintf('\nWARNING: found neg. xsize in SPM header. Ignoring the sign.');
        fprintf('\nIs this right? Look for THIS in the code and change if you dont like it');
        spm_hdr.xsize = abs(spm_hdr.xsize);
    end

    x = ( x - spm_hdr.origin(1) )* spm_hdr.xsize;
    y = ( y - spm_hdr.origin(2) )* spm_hdr.ysize;
    z = ( z - spm_hdr.origin(3) )* spm_hdr.zsize;

    xi = ( xi - hdr.origin(1) )* hdr.xsize;
    yi = ( yi - hdr.origin(2) )* hdr.ysize;
    zi = ( zi - hdr.origin(3) )* hdr.zsize;

    if hdr.zdim >1
        spm_dataR = interp3(x,y,z, spm_data, xi,yi,zi,'nearest');
    else
        spm_dataR=spm_data;
    end

    [D , inds]= mk_overlay(args.threshold, D, spm_dataR, 257);

    %configure the colormap:
    set_func_colors

    xstretch = hdr.xdim/spm_hdr.xdim;
    ystretch = hdr.ydim/spm_hdr.ydim;
    zstretch = hdr.zdim/spm_hdr.zdim;
else
    xstretch = 1;
    ystretch = 1;
    zstretch = 1;
end


if ~isempty(args.spm_file2)
    % load SPM into memory and create the overlay
    spm_file2 = args.spm_file2;
    fprintf('\nLoading ... %s', spm_file2);
    spm_hdr2 = read_hdr(spm_file2);
    if spm_hdr2.xsize < 0;
        fprintf('\nWARNING: found neg. xsize in SPM header. Ignoring the sign.');
        fprintf('\nIs this right? Look for THIS in the code and change if you dont like it');
        spm_hdr2.xsize = abs(spm_hdr2.xsize);
    end
    spm_data2 = read_img(spm_hdr2,spm_file2);
    % get rid of the NaNs
    spm_data2(find(spm_data2==NaN))=0;
    spm_data2 = reshape(spm_data2, spm_hdr.xdim, spm_hdr.ydim, spm_hdr.zdim);
    spm_scale2 =  SPM_scale_factor;
    spm_data2 = double(spm_data2);
    %spm_data2 = spm_data2*spm_scale2;
    figure(histFig), subplot(3,1,3),hist(spm_data2(spm_data2~=0),100), title('Stats Map (Blue)')
    figure(myfig)

    % resample the paramter map to fit the anatomical one
    [x,y,z] = meshgrid(1:spm_hdr2.ydim , 1:spm_hdr2.xdim, 1:spm_hdr2.zdim);
    [xi,yi, zi] = meshgrid(1:hdr.ydim , 1:hdr.xdim, 1:hdr.zdim);

    % optional in case the origin is not set in the image headers...
    if args.ignore_origin==1
        spm_hdr2.origin = [0 0 0];
        hdr.origin = [0 0 0];
    end

    x = ( x - spm_hdr2.origin(1) )* spm_hdr2.xsize;
    y = ( y - spm_hdr2.origin(2) )* spm_hdr2.ysize;
    z = ( z - spm_hdr2.origin(3) )* spm_hdr2.zsize;

    xi = ( xi - hdr.origin(1) )* hdr.xsize;
    yi = ( yi - hdr.origin(2) )* hdr.ysize;
    zi = ( zi - hdr.origin(3) )* hdr.zsize;

    if hdr.zdim >1
        spm_dataB = interp3(x,y,z, spm_data2, xi,yi,zi,'nearest');
    else
        spm_dataB = spm_data2;
    end

    [D , inds2]= mk_overlay(args.threshold2, D, spm_dataB, 513);
    D = mk_overlap(D,inds,inds2);

    %configure the colormap:
    %set_func_colors2

    xstretch = hdr.xdim/spm_hdr2.xdim;
    ystretch = hdr.ydim/spm_hdr2.ydim;
    zstretch = hdr.zdim/spm_hdr2.zdim;
else
    xstretch = 1;
    ystretch = 1;
    zstretch = 1;
end


if ~isempty(args.tseries_file)
    % load up the time series into memory
    isNIFTI=0;
    %first, ,make sure the name is OK.  we want just the root of the time
    filename = args.tseries_file;
    [func_data func_hdr] = read_img(filename);
    
    % save memory?
%    func_data = int16(func_data);
    
    if isfield(func_hdr,'magic');
        func_hdr = nii2avw_hdr(func_hdr);
        isNIFTI=1
    end

    if (~isNIFTI) & (func_hdr.tdim==1)
        root = filename(1:end-8);
        [func_data func_hdr]=read_img_series(root);
    end

    % optional in case the origin is not set in the image headers...
    if args.ignore_origin==1
        func_hdr.origin = [0 0 0 0 0]';
    end
end

% determine the first point for the extraction
if isempty(args.xyz)
    x=ceil(hdr.xdim/2);
    y=ceil(hdr.ydim/2);
    z=ceil(hdr.zdim/2);
else
    x = args.xyz(1);
    y = args.xyz(2);
    z = args.xyz(3);

    [x,y,z] = mm2vox(hdr, args.xyz)
end


% Update the Display of the orthogonal views here
[fig1, fig2, fig3] =  ov(hdr,D,x,y,z,0);
if strcmp(computer,'PCWIN')
    set(gcf, 'Renderer','OpenGL');
end

% create the gaussian kernel for the filter (to be used later)
% uses the stats toolbox
% g = make_gaussian(49,1,100);
%
oldT1 = args.threshold;
oldT2 = args.threshold2;

button=1;
while (button ~= 122)  % until they press Z.  122 is ASCII for the Z key

    if (args.threshold ~= oldT1) | (args.threshold2 ~= oldT2)
        [D , inds]= mk_overlay(args.threshold, Dscaled, spm_dataR, 257);
        if ~isempty(args.spm_file2)
            [D , inds2]= mk_overlay(args.threshold2, D, spm_dataB, 513);
            D = mk_overlap(D, inds, inds2);
            oldT2 = args.threshold2;
        end
        oldT1 = args.threshold;
        fprintf('\nUpdating thresholds ... %f , %f', oldT1, oldT2)
    end

    % now get into the interactive sampling loop:
    [fig1, fig2, fig3] =  ov(hdr,D,x,y,z,0);

    fprintf('\ncoords = (%3.2f, %3.2f, %3.2f) mm,  \ncoords = (%3.2f, %3.2f, %3.2f) vox , \nAnat val= %f',...
        hdr.xsize *( x - hdr.origin(1) ), ...
        hdr.ysize *( y - hdr.origin(2) ), ...
        hdr.zsize *( z - hdr.origin(3) ), ...
        x,y,z, ...
        anat_data(x,y,z));%*anat_scale );

    % figure out what the coordinates correspond to in the SPM image
    if ~isempty(args.spm_file)
        % get the values in the stats map
        [mx, my, mz] = vox2mm(hdr, [x,y,z]);
        [xs, ys, zs] = mm2vox(spm_hdr, [mx, my, mz]);

    else
        xs = x;
        ys = y;
        zs = z;

        spm_hdr=hdr;
    end

    % figure out what the coordinates correspond to in the SPM2 image
    if ~isempty(args.spm_file2)
        % get the values in the stats map
        [mx, my, mz] = vox2mm(hdr, [x,y,z]);
        [xs, ys, zs] = mm2vox(spm_hdr2, [mx, my, mz]);

        %fprintf('\nSPM2 val= %d', spm_data2(xs,ys,zs));%*spm_scale2 );

    end

    % extend the coordinates to fill a whole ROI
    % (figure out which voxels get extracted)
    if ~isempty(args.anat_file)

        % just in case they forgot to set that flag, if they selected a
        % mask file, it means they are doing a mask ROI
        if ~isempty(args.mask_file)
            args.ROItype='maskFile';
        end

        % limits of the ROI
        roi = args.ROIsize;

        xmin = max([1 xs-roi]);
        xmax = min([hdr.xdim xs+roi]);

        ymin = max([1 ys-roi]);
        ymax = min([hdr.ydim ys+roi]);

        zmin = max([1 zs-roi]);
        zmax = min([hdr.zdim zs+roi]);

        % first figure which voxels
        switch args.ROItype
            case 'cube'
                [xx,yy,zz] = ndgrid([xmin:xmax], [ymin:ymax], [zmin:zmax]);
                nlist = length(xx(:));
                fx = reshape(xx,nlist,1);
                fy = reshape(yy,nlist,1);
                fz = reshape(zz,nlist,1);

                func_xyz = [fx fy fz];   % a list of all voxels within the cube

            case 'sphere'
                %nlist = (2*args.ROIsize + 1)^3; % total # of voxels within a cube
                [xx,yy,zz] = ndgrid([xmin:xmax], [ymin:ymax], [zmin:zmax]);
                nlist = length(xx(:));
                fx = reshape(xx,nlist,1);
                fy = reshape(yy,nlist,1);
                fz = reshape(zz,nlist,1);

                cube_xyz = [fx fy fz];   % a list of all voxels within the cube
                dist_cube = sqrt(...
                    (spm_hdr.xsize * (fx - xs)).^2 + ...
                    (spm_hdr.ysize * (fy - ys)).^2 + ...
                    (spm_hdr.zsize * (fz - zs)).^2);    % a list of distances in mm

                sphere_xyz = cube_xyz(dist_cube <= args.ROIsize, :); % a list of voxels within sphere
                num_voxels = size(sphere_xyz,1); % len_list is the # of voxels within sphere

                % keep only those above threshold in the spm_data
                func_xyz =  [];
                if ~isempty(args.spm_file)
                    if args.threshold >= 0
                        for v=1: num_voxels
                            if spm_data(sphere_xyz(v,1), sphere_xyz(v,2), sphere_xyz(v,3)) ...
                                    >= args.threshold;
                                func_xyz = [func_xyz; sphere_xyz(v,:)];
                            end
                        end
                    else
                        for v=1: num_voxels
                            if spm_data(sphere_xyz(v,1), sphere_xyz(v,2), sphere_xyz(v,3)) ...
                                    <= args.threshold;
                                func_xyz = [func_xyz; sphere_xyz(v,:)];
                            end
                        end
                    end


                    if ~isempty(args.spm_file2)
                        func_xyz2 =  [];
                        if args.threshold2 >= 0
                            for v=1: size(func_xyz,1)
                                if spm_data2(func_xyz(v,1), func_xyz(v,2), func_xyz(v,3)) ...
                                        >= args.threshold2;
                                    func_xyz2 = [func_xyz2; func_xyz(v,:)];
                                end
                            end
                        else
                            for v=1: size(func_xyz,1)
                                if spm_data2(func_xyz(v,1), func_xyz(v,2), func_xyz(v,3)) ...
                                        <= args.threshold2;
                                    func_xyz2 = [func_xyz2; func_xyz(v,:)];
                                end
                            end
                        end
                        func_xyz=func_xyz2;
                    end
                else
                    func_xyz = sphere_xyz;
                end

            case 'voxFile'
                if ~isempty(args.voxFile)
                    func_xyz = load(args.voxFile)
                else
                    fprintf('\nERROR: NO VOXEL FILE (args.voxFile) WAS SPECIFIED - ABORT');
                    fprintf('\nI am very disappointed\n');
                end
            case 'maskFile'
                if ~isempty(args.mask_file)
                    mask_hdr = read_hdr(args.mask_file);
                    mask_data = read_img(args.mask_file);
                    mask_data = reshape(mask_data, mask_hdr.xdim, mask_hdr.ydim, mask_hdr.zdim);
                    %func = find(mask_data >= args.threshold);
                    func = find(mask_data);
                    [fx, fy, fz] = ind2sub(size(mask_data), func);
                    if ~isempty(args.tseries_file)
                        % convert to time series image coordinates
                        [fx, fy, fz] = vox2mm(mask_hdr, [fx,fy,fz]);
                        [fx, fy, fz] = mm2vox(func_hdr, [fx,fy,fz]);
                    else
                        % convert to the stats image coordinates
                        [fx, fy, fz] = vox2mm(mask_hdr, [fx,fy,fz]);
                        [fx, fy, fz] = mm2vox(spm_hdr, [fx,fy,fz]);
                    end
                    func_xyz = [fx fy fz];
                else
                    fprintf('\nERROR: NO MASK FILE (args.mask_file) WAS SPECIFIED - ABORT');
                    fprintf('\nHow could you ...?\n');
                    return
                end
                %keyboard
            otherwise
                fprintf('\nError. Alowed ROI types are: cube, sphere, voxFile, maskFile.')
                fprintf('\nDo not let it happen again... Exiting\n')
                return
        end

        if args.doMovie
            fprintf('\nLooping:\n');

            doAVI=0;
            if doAVI
                aviF = avifile(sprintf('%s.avi',args.output_name))
                clear M;
            end
            fmin = min(func_data(:));
            fmax = max(func_data(:));
            range = fmax- fmin;
            for count=1:size(func_data,1)

                d = reshape(func_data(count,:), func_hdr.xdim, func_hdr.ydim, func_hdr.zdim);
                dd = (d-fmin)*256/range;
                if ~isempty(args.wscale)
                    dd = (d-wscale(1))*256 / (args.wscale(2)-args.wscale(1));
                    dd(find(dd>256)) = 256;
                    dd(find(dd<1))=1;
                end

                figure(myfig)
                [fig1, fig2, fig3] =  ov(func_hdr,dd,x,y,z,roi);
                fprintf('\r(x,y,z,t)=  (%d %d %d %d)', x, y, z, count);

                drawnow
                if doAVI
                    M = getframe(gcf);
                    aviF=addframe(aviF, M);
                end
                pause(0.1)
            end

            if doAVI
                aviF=close(aviF);
            end
            % redraw the time series plot
            %         subplot 224, plot(tdata,'r'); hold off;
            %         xlabel('scan #'), title('Signal')
            %         set(gca,'Position',[ 0.55    0.15    0.40    0.30]);axis tight ;
        end

        % fill in the ROI so you know what pixels got extracted
        if ~isempty(func_xyz)
            vx = func_xyz(:,1);
            vy = func_xyz(:,2);
            vz = func_xyz(:,3);

			% match the voxels in the spm to the anatomical frame of
			% reference
            [vx2, vy2, vz2 ] = vox2mm(spm_hdr, func_xyz);
            [vx2, vy2, vz2 ] = mm2vox(hdr, [vx2, vy2, vz2]);
			anat_xyz = [vx2 vy2 vz2];
			
			vx2 = round(vx2); vy2 = round(vy2); vz2 = round(vz2);
			

            xind = find(vx2==x);
            axes(fig3), hold on, plot(vy2(xind), vz2(xind),'mx');

            yind = find(vy2==y);
            axes(fig2), hold on, plot(vx2(yind), vz2(yind),'mx');

            zind = find(vz2==z);
            axes(fig1), hold on, plot(vy2(zind), vx2(zind),'mx');

            if ~isempty(args.spm_file)
                spm_val = zeros(size(vx,1),1);
                for p=1:length(spm_val)
                    spm_val(p)= spm_data(vx(p),vy(p),vz(p));
                end
                spm_val = mean(spm_val(find(~isnan(spm_val))));
                fprintf('\nMean ROI val in SPM n.1 = %f -- %d voxels\n', spm_val, length(vx) );
            end
            if ~isempty(args.spm_file2)
                spm_val2 = zeros(size(vx2,1),1);
                for p=1:length(spm_val2)
                    spm_val2(p)= spm_data2(vx(p),vy(p),vz(p));
                end
                spm_val2 = mean(spm_val2(find(~isnan(spm_val2))));
                fprintf('\nMean ROI val in SPM n.2 = %f -- %d voxels\n', spm_val2, length(vx2) );
            end
            drawnow
        else
            fprintf('\nFound no elligible voxels at this location');
            fprintf('\nThat is too bad, I really wanted to extract a time series');
        end
	end

	if button==3 && ~isempty(func_xyz)
            % 6/27/2008: right mouse button means we save pix coordinates to file
            % here we can write those pixels without loading a time course.
			% NB : we save the pixel indices for BOTH the anatomical and
			% functional images
			fprintf('\nsaving:    %s_voxels.dat',args.output_name)
            fprintf('\nsaving:    %s_anvoxels.dat',args.output_name)
            str=sprintf('save %s_voxels.dat func_xyz -ASCII', args.output_name); eval(str);
			str=sprintf('save %s_anvoxels.dat anat_xyz -ASCII', args.output_name); eval(str);
	end
	
    % and extract the time series in the selected voxels
    if ~isempty(func_xyz) & ~isempty(args.tseries_file)

        tmp = xtractROI(func_hdr, func_data, vx, vy, vz);
        rawtdata = tmp;

        % filtering stuff:
        % tmp = smoothdata2(tmp, TR, 0.009, 0.3, 3);
        if args.doGfilter
            %disp('Gaussian filter ...')
            MeanBefore=mean(tmp);
            tmp = conv(g,tmp-MeanBefore);
            tmp = tmp(50:end-50 )+ MeanBefore;
			%tmp = smoothdata2(tmp, 1, 0.009, 0.4, 11);
            MeanAfter=mean(tmp);
        end

        series_mean = mean(tmp);
        series_std = std(tmp);

        fprintf('\ntemporal mean: %f , temporal std. dev.: %f', ...
            series_mean, series_std);

        if args.doDetrend
            disp('detrending ...')
            dtmp = mydetrend(tmp');
            load coeffs.mat
            tmp=dtmp;
            tmp = 100 * tmp / series_mean;
		else
			% signal change computation:
			% tmp = 100 * (tmp' - series_mean) / series_mean;
            %    tmp = rawtdata;
		end

		% Do the plots
        tdata = tmp;
        subplot 224, plot(tdata,'r'); grid on
        xlabel('scan #'), title('Signal')
        set(gca,'Position',[ 0.55    0.15    0.40    0.30]);axis tight ;
		

        if button==3 | strcmp(args.ROItype,'maskFile') | strcmp(args.ROItype,'voxFile')
            % right mouse button means we save data to file
            fprintf('\nsaving:   %s_tdata.dat, and %s_voxels.dat',...
                args.output_name,args.output_name)
            str=sprintf('save %s_tdata.dat tdata -ASCII', args.output_name); eval(str);
            str=sprintf('save %s_rawtdata.dat rawtdata -ASCII', args.output_name); eval(str);
            str=sprintf('save %s_voxels.dat func_xyz -ASCII', args.output_name); eval(str);

            % If the causality flag is on, then we also compute the
            % different maps.
            if args.causalMap
                % fprintf('\nNo Causality Analysis Yet. I am just not ready for that kind of commitment!')

                drawnow
                if exist('DesMat.dat')
                    fprintf('\nLoading design matrix (DesMat.dat) to remove known effects')
                    DM = load('DesMat.dat');

                else
                    fprintf('\nDid not find design matrix (DesMat.dat) to remove known effects')
                    DM = [];
                end
                %imgDominateFun(func_hdr, func_data, func_xyz, DM);
				fprintf('\nComputing granger causality maps relative to this cluster ...');
				imgGrangerFun(func_hdr, func_data, func_xyz, DM,1);
				figure ; lightbox('grangerF');
				figure(myfig)

				fprintf('\nMoving Granger Results to %s_granger ...', args.output_name);
				str = sprintf('!mkdir %s_granger',args.output_name);				eval(str)
				str = sprintf('!mv granger* %s_granger', args.output_name);			eval(str)
				str = sprintf('!mv %s_*.dat %s_granger', args.output_name ,args.output_name);			eval(str);

            end
        end

        if ~isempty(args.onsets)

            [ev_avg ev_std] = event_avg(tdata,args.onsets,args.window,1);

            subplot 224, plot(ev_avg,'r');axis tight ; hold off;
            dlha = get(gca,'children');
            set(dlha(:),'LineWidth',2);
            hold on
            subplot 224, errorbar([1:length(ev_avg)], ev_avg,...
                ev_std, ev_std,'r');
            hold off
            subplot(224), title (sprintf('ROI at %d %d %d ', xs , ys, zs))
            set(gca, 'Xtick',[0:2:args.window])
            xlabel('scan #'), ylabel('%signal')
            set(gca,'Position',[ 0.55    0.15    0.40    0.30]);

            if button==3 | strcmp(args.ROItype,'maskFile') | args.interact==0
                % right mouse button means we save data to file
                % and if so desired, we compute the causality stuff
                tmp = [ev_avg ev_std];
                fprintf('\nsaving:  %s_avg.dat ',args.output_name)
                str=sprintf('save %s_avg.dat tmp -ASCII', args.output_name); eval(str);

            end

            % now display the image of event averages
            load allevents
            if isempty(EvFig)
                EvFig = figure;
                set(gcf,'Position',[1 1 360,320]);
                set(gcf, 'Name', 'Events image');
            end

            figure(EvFig);
            imagesc(allevents); colorbar
            title('Image of all the events in 2D')
            xlabel('Time (scans)'), ylabel('Event number')
            % return focus to other figure
            figure(myfig);
        end

    end


    if args.doFFT & exist('tdata')
        if isempty(FFTfig)
            % open a window for displaying the frequency content of the time courses
            FFTfig = figure;
            set(gcf,'Position',[400 1 360,320]);
            set(gcf, 'Name', 'Frequency Spectrum');
        end
        figure(FFTfig),hold off,
        fdata = fft(tdata - mean(tdata));
        subplot(211), plot(linspace(0,1,length(fdata)/2+1), abs(fdata(1:end/2+1)),'r')
        title('FFT magnitude (mean removed)')
        xlabel('Frequency'), ylabel('Magnitude')
        subplot(212), plot(linspace(-1,1,length(tdata)), angle(fftshift(fft(tdata - mean(tdata)))),'r')
        title('FFT Phase(mean removed)')

        xlabel('Frequency'), ylabel('Phase')
        figure(myfig)
    end




    % Get the next user defined point if running in interactive mode
    if (args.interact)
        oldi = i;        oldj = j;
        [i j button] = ginput(1);
        if i<1 | j<1
             i=oldi;  j=oldj;
        end
         
        if isempty(args.xyz)
            fprintf('\n---');
            i=round(i);j=round(j);
            fig = floor(gca);
            switch(fig)
                case floor(fig1)
                    x=j;
                    y=i;
                case floor(fig2)
                    z=j;
                    x=i;
                case floor(fig3)
                    y=i;
                    z=j;
            end
        else
            fprintf('\nClear the text coordinates from the control panel if you want to use the mouse')
            x = args.xyz(1);
            y = args.xyz(2);
            z = args.xyz(3);
            [x, y, z] = mm2vox(hdr, [x,y,z])
        end

        if(button==UPKEY) %30 = up arrow key to grow ROI
            args.ROIsize= args.ROIsize + 1;

        elseif(button==DNKEY)  %31 = down arrow key to shrink ROI22222222222
            args.ROIsize=  args.ROIsize-1;

        elseif(button==RTKEY)  %29 = right arrow key to increase threshold by 10%
            args.threshold=args.threshold*1.1;

        elseif(button==LTKEY)  %28 = left arrow key to decrease threshold by 10%
            args.threshold = args.threshold*0.9;
        end
        fprintf('\nNew ROIsize = %0.2f mm , thresh = %0.2f ', ...
            args.ROIsize,args.threshold);

    else
        break;
    end
%     % exit the loop by clicking outside or hitting "Z"
%     if button==1 | button ==3
%         if i<1 | j<1
%             break
%         end
%     end

    if  button==122
        break
    end

    if ACTIVE==0
        break
    end

end

result = args;
fprintf('\nLater!')
return

